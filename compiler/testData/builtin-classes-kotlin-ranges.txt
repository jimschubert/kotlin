package-fragment kotlin.ranges

@kotlin.Deprecated(level = DeprecationLevel.WARNING, message = "Use IntProgression instead.", replaceWith = kotlin.ReplaceWith(expression = "IntProgression", imports = {})) public open class ByteProgression : kotlin.Progression<kotlin.Byte> {
    /*primary*/ @kotlin.Deprecated(message = "This constructor will become private soon. Use ByteProgression.fromClosedRange() instead.", replaceWith = kotlin.ReplaceWith(expression = "ByteProgression.fromClosedRange(start, endInclusive, step)", imports = {})) public constructor ByteProgression(/*0*/ start: kotlin.Byte, /*1*/ endInclusive: kotlin.Byte, /*2*/ step: kotlin.Int)
    @kotlin.Deprecated(message = "Use 'last' property instead.") public open override /*1*/ val end: kotlin.Byte
        public open override /*1*/ fun <get-end>(): kotlin.Byte
    public final val first: kotlin.Byte
        public final fun <get-first>(): kotlin.Byte
    @kotlin.Deprecated(message = "Use 'step' property instead.", replaceWith = kotlin.ReplaceWith(expression = "step", imports = {})) public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public final val last: kotlin.Byte
        public final fun <get-last>(): kotlin.Byte
    @kotlin.Deprecated(message = "Use 'first' property instead.", replaceWith = kotlin.ReplaceWith(expression = "first", imports = {})) public open override /*1*/ val start: kotlin.Byte
        public open override /*1*/ fun <get-start>(): kotlin.Byte
    public final val step: kotlin.Int
        public final fun <get-step>(): kotlin.Int
    public open fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.collections.ByteIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final fun fromClosedRange(/*0*/ rangeStart: kotlin.Byte, /*1*/ rangeEnd: kotlin.Byte, /*2*/ step: kotlin.Int): kotlin.ranges.ByteProgression
    }
}

internal final class ByteProgressionIterator : kotlin.collections.ByteIterator {
    /*primary*/ public constructor ByteProgressionIterator(/*0*/ first: kotlin.Byte, /*1*/ last: kotlin.Byte, /*2*/ step: kotlin.Int)
    private final val finalElement: kotlin.Int
        private final fun <get-finalElement>(): kotlin.Int
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public final val step: kotlin.Int
        public final fun <get-step>(): kotlin.Int
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Byte
    public open override /*1*/ fun nextByte(): kotlin.Byte
}

@kotlin.Deprecated(level = DeprecationLevel.WARNING, message = "Use IntRange instead.", replaceWith = kotlin.ReplaceWith(expression = "IntRange", imports = {})) public final class ByteRange : kotlin.ranges.ByteProgression, kotlin.ranges.ClosedRange<kotlin.Byte> {
    /*primary*/ public constructor ByteRange(/*0*/ start: kotlin.Byte, /*1*/ endInclusive: kotlin.Byte)
    @kotlin.Deprecated(message = "Use endInclusive instead.", replaceWith = kotlin.ReplaceWith(expression = "endInclusive", imports = {})) public open override /*2*/ val end: kotlin.Byte
        public open override /*2*/ fun <get-end>(): kotlin.Byte
    public open override /*1*/ val endInclusive: kotlin.Byte
        public open override /*1*/ fun <get-endInclusive>(): kotlin.Byte
    public final override /*1*/ /*fake_override*/ val first: kotlin.Byte
        public final override /*1*/ /*fake_override*/ fun <get-first>(): kotlin.Byte
    @kotlin.Deprecated(message = "Use 'step' property instead.", replaceWith = kotlin.ReplaceWith(expression = "step", imports = {})) public open override /*1*/ /*fake_override*/ val increment: kotlin.Int
        public open override /*1*/ /*fake_override*/ fun <get-increment>(): kotlin.Int
    public final override /*1*/ /*fake_override*/ val last: kotlin.Byte
        public final override /*1*/ /*fake_override*/ fun <get-last>(): kotlin.Byte
    public open override /*2*/ val start: kotlin.Byte
        public open override /*2*/ fun <get-start>(): kotlin.Byte
    public final override /*1*/ /*fake_override*/ val step: kotlin.Int
        public final override /*1*/ /*fake_override*/ fun <get-step>(): kotlin.Int
    public open override /*1*/ fun contains(/*0*/ value: kotlin.Byte): kotlin.Boolean
    public open override /*2*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.collections.ByteIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.ranges.ByteRange
            public final fun <get-EMPTY>(): kotlin.ranges.ByteRange
    }
}

public open class CharProgression : kotlin.Progression<kotlin.Char> {
    /*primary*/ @kotlin.Deprecated(message = "This constructor will become private soon. Use CharProgression.fromClosedRange() instead.", replaceWith = kotlin.ReplaceWith(expression = "CharProgression.fromClosedRange(start, endInclusive, step)", imports = {})) public constructor CharProgression(/*0*/ start: kotlin.Char, /*1*/ endInclusive: kotlin.Char, /*2*/ step: kotlin.Int)
    @kotlin.Deprecated(message = "Use 'last' property instead.") public open override /*1*/ val end: kotlin.Char
        public open override /*1*/ fun <get-end>(): kotlin.Char
    public final val first: kotlin.Char
        public final fun <get-first>(): kotlin.Char
    @kotlin.Deprecated(message = "Use 'step' property instead.", replaceWith = kotlin.ReplaceWith(expression = "step", imports = {})) public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public final val last: kotlin.Char
        public final fun <get-last>(): kotlin.Char
    @kotlin.Deprecated(message = "Use 'first' property instead.", replaceWith = kotlin.ReplaceWith(expression = "first", imports = {})) public open override /*1*/ val start: kotlin.Char
        public open override /*1*/ fun <get-start>(): kotlin.Char
    public final val step: kotlin.Int
        public final fun <get-step>(): kotlin.Int
    public open fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.collections.CharIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final fun fromClosedRange(/*0*/ rangeStart: kotlin.Char, /*1*/ rangeEnd: kotlin.Char, /*2*/ step: kotlin.Int): kotlin.ranges.CharProgression
    }
}

internal final class CharProgressionIterator : kotlin.collections.CharIterator {
    /*primary*/ public constructor CharProgressionIterator(/*0*/ first: kotlin.Char, /*1*/ last: kotlin.Char, /*2*/ step: kotlin.Int)
    private final val finalElement: kotlin.Int
        private final fun <get-finalElement>(): kotlin.Int
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public final val step: kotlin.Int
        public final fun <get-step>(): kotlin.Int
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Char
    public open override /*1*/ fun nextChar(): kotlin.Char
}

public final class CharRange : kotlin.ranges.CharProgression, kotlin.ranges.ClosedRange<kotlin.Char> {
    /*primary*/ public constructor CharRange(/*0*/ start: kotlin.Char, /*1*/ endInclusive: kotlin.Char)
    @kotlin.Deprecated(message = "Use endInclusive instead.", replaceWith = kotlin.ReplaceWith(expression = "endInclusive", imports = {})) public open override /*2*/ val end: kotlin.Char
        public open override /*2*/ fun <get-end>(): kotlin.Char
    public open override /*1*/ val endInclusive: kotlin.Char
        public open override /*1*/ fun <get-endInclusive>(): kotlin.Char
    public final override /*1*/ /*fake_override*/ val first: kotlin.Char
        public final override /*1*/ /*fake_override*/ fun <get-first>(): kotlin.Char
    @kotlin.Deprecated(message = "Use 'step' property instead.", replaceWith = kotlin.ReplaceWith(expression = "step", imports = {})) public open override /*1*/ /*fake_override*/ val increment: kotlin.Int
        public open override /*1*/ /*fake_override*/ fun <get-increment>(): kotlin.Int
    public final override /*1*/ /*fake_override*/ val last: kotlin.Char
        public final override /*1*/ /*fake_override*/ fun <get-last>(): kotlin.Char
    public open override /*2*/ val start: kotlin.Char
        public open override /*2*/ fun <get-start>(): kotlin.Char
    public final override /*1*/ /*fake_override*/ val step: kotlin.Int
        public final override /*1*/ /*fake_override*/ fun <get-step>(): kotlin.Int
    public open override /*1*/ fun contains(/*0*/ value: kotlin.Char): kotlin.Boolean
    public open override /*2*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.collections.CharIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.ranges.CharRange
            public final fun <get-EMPTY>(): kotlin.ranges.CharRange
    }
}

public interface ClosedRange</*0*/ T : kotlin.Comparable<T>> : kotlin.ranges.Range<T> {
    @kotlin.Deprecated(message = "Use endInclusive instead.", replaceWith = kotlin.ReplaceWith(expression = "endInclusive", imports = {})) public open override /*1*/ val end: T
        public open override /*1*/ fun <get-end>(): T
    public abstract val endInclusive: T
        public abstract fun <get-endInclusive>(): T
    public abstract override /*1*/ val start: T
        public abstract override /*1*/ fun <get-start>(): T
    public open override /*1*/ fun contains(/*0*/ value: T): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
}

public open class IntProgression : kotlin.Progression<kotlin.Int> {
    /*primary*/ @kotlin.Deprecated(message = "This constructor will become private soon. Use IntProgression.fromClosedRange() instead.", replaceWith = kotlin.ReplaceWith(expression = "IntProgression.fromClosedRange(start, endInclusive, step)", imports = {})) public constructor IntProgression(/*0*/ start: kotlin.Int, /*1*/ endInclusive: kotlin.Int, /*2*/ step: kotlin.Int)
    @kotlin.Deprecated(message = "Use 'last' property instead.") public open override /*1*/ val end: kotlin.Int
        public open override /*1*/ fun <get-end>(): kotlin.Int
    public final val first: kotlin.Int
        public final fun <get-first>(): kotlin.Int
    @kotlin.Deprecated(message = "Use 'step' property instead.", replaceWith = kotlin.ReplaceWith(expression = "step", imports = {})) public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public final val last: kotlin.Int
        public final fun <get-last>(): kotlin.Int
    @kotlin.Deprecated(message = "Use 'first' property instead.", replaceWith = kotlin.ReplaceWith(expression = "first", imports = {})) public open override /*1*/ val start: kotlin.Int
        public open override /*1*/ fun <get-start>(): kotlin.Int
    public final val step: kotlin.Int
        public final fun <get-step>(): kotlin.Int
    public open fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.collections.IntIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final fun fromClosedRange(/*0*/ rangeStart: kotlin.Int, /*1*/ rangeEnd: kotlin.Int, /*2*/ step: kotlin.Int): kotlin.ranges.IntProgression
    }
}

internal final class IntProgressionIterator : kotlin.collections.IntIterator {
    /*primary*/ public constructor IntProgressionIterator(/*0*/ first: kotlin.Int, /*1*/ last: kotlin.Int, /*2*/ step: kotlin.Int)
    private final val finalElement: kotlin.Int
        private final fun <get-finalElement>(): kotlin.Int
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public final val step: kotlin.Int
        public final fun <get-step>(): kotlin.Int
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Int
    public open override /*1*/ fun nextInt(): kotlin.Int
}

public final class IntRange : kotlin.ranges.IntProgression, kotlin.ranges.ClosedRange<kotlin.Int> {
    /*primary*/ public constructor IntRange(/*0*/ start: kotlin.Int, /*1*/ endInclusive: kotlin.Int)
    @kotlin.Deprecated(message = "Use endInclusive instead.", replaceWith = kotlin.ReplaceWith(expression = "endInclusive", imports = {})) public open override /*2*/ val end: kotlin.Int
        public open override /*2*/ fun <get-end>(): kotlin.Int
    public open override /*1*/ val endInclusive: kotlin.Int
        public open override /*1*/ fun <get-endInclusive>(): kotlin.Int
    public final override /*1*/ /*fake_override*/ val first: kotlin.Int
        public final override /*1*/ /*fake_override*/ fun <get-first>(): kotlin.Int
    @kotlin.Deprecated(message = "Use 'step' property instead.", replaceWith = kotlin.ReplaceWith(expression = "step", imports = {})) public open override /*1*/ /*fake_override*/ val increment: kotlin.Int
        public open override /*1*/ /*fake_override*/ fun <get-increment>(): kotlin.Int
    public final override /*1*/ /*fake_override*/ val last: kotlin.Int
        public final override /*1*/ /*fake_override*/ fun <get-last>(): kotlin.Int
    public open override /*2*/ val start: kotlin.Int
        public open override /*2*/ fun <get-start>(): kotlin.Int
    public final override /*1*/ /*fake_override*/ val step: kotlin.Int
        public final override /*1*/ /*fake_override*/ fun <get-step>(): kotlin.Int
    public open override /*1*/ fun contains(/*0*/ value: kotlin.Int): kotlin.Boolean
    public open override /*2*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.collections.IntIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.ranges.IntRange
            public final fun <get-EMPTY>(): kotlin.ranges.IntRange
    }
}

public open class LongProgression : kotlin.Progression<kotlin.Long> {
    /*primary*/ @kotlin.Deprecated(message = "This constructor will become private soon. Use LongProgression.fromClosedRange() instead.", replaceWith = kotlin.ReplaceWith(expression = "LongProgression.fromClosedRange(start, endInclusive, step)", imports = {})) public constructor LongProgression(/*0*/ start: kotlin.Long, /*1*/ endInclusive: kotlin.Long, /*2*/ step: kotlin.Long)
    @kotlin.Deprecated(message = "Use 'last' property instead.") public open override /*1*/ val end: kotlin.Long
        public open override /*1*/ fun <get-end>(): kotlin.Long
    public final val first: kotlin.Long
        public final fun <get-first>(): kotlin.Long
    @kotlin.Deprecated(message = "Use 'step' property instead.", replaceWith = kotlin.ReplaceWith(expression = "step", imports = {})) public open override /*1*/ val increment: kotlin.Long
        public open override /*1*/ fun <get-increment>(): kotlin.Long
    public final val last: kotlin.Long
        public final fun <get-last>(): kotlin.Long
    @kotlin.Deprecated(message = "Use 'first' property instead.", replaceWith = kotlin.ReplaceWith(expression = "first", imports = {})) public open override /*1*/ val start: kotlin.Long
        public open override /*1*/ fun <get-start>(): kotlin.Long
    public final val step: kotlin.Long
        public final fun <get-step>(): kotlin.Long
    public open fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.collections.LongIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final fun fromClosedRange(/*0*/ rangeStart: kotlin.Long, /*1*/ rangeEnd: kotlin.Long, /*2*/ step: kotlin.Long): kotlin.ranges.LongProgression
    }
}

internal final class LongProgressionIterator : kotlin.collections.LongIterator {
    /*primary*/ public constructor LongProgressionIterator(/*0*/ first: kotlin.Long, /*1*/ last: kotlin.Long, /*2*/ step: kotlin.Long)
    private final val finalElement: kotlin.Long
        private final fun <get-finalElement>(): kotlin.Long
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    private final var next: kotlin.Long
        private final fun <get-next>(): kotlin.Long
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Long): kotlin.Unit
    public final val step: kotlin.Long
        public final fun <get-step>(): kotlin.Long
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Long
    public open override /*1*/ fun nextLong(): kotlin.Long
}

public final class LongRange : kotlin.ranges.LongProgression, kotlin.ranges.ClosedRange<kotlin.Long> {
    /*primary*/ public constructor LongRange(/*0*/ start: kotlin.Long, /*1*/ endInclusive: kotlin.Long)
    @kotlin.Deprecated(message = "Use endInclusive instead.", replaceWith = kotlin.ReplaceWith(expression = "endInclusive", imports = {})) public open override /*2*/ val end: kotlin.Long
        public open override /*2*/ fun <get-end>(): kotlin.Long
    public open override /*1*/ val endInclusive: kotlin.Long
        public open override /*1*/ fun <get-endInclusive>(): kotlin.Long
    public final override /*1*/ /*fake_override*/ val first: kotlin.Long
        public final override /*1*/ /*fake_override*/ fun <get-first>(): kotlin.Long
    @kotlin.Deprecated(message = "Use 'step' property instead.", replaceWith = kotlin.ReplaceWith(expression = "step", imports = {})) public open override /*1*/ /*fake_override*/ val increment: kotlin.Long
        public open override /*1*/ /*fake_override*/ fun <get-increment>(): kotlin.Long
    public final override /*1*/ /*fake_override*/ val last: kotlin.Long
        public final override /*1*/ /*fake_override*/ fun <get-last>(): kotlin.Long
    public open override /*2*/ val start: kotlin.Long
        public open override /*2*/ fun <get-start>(): kotlin.Long
    public final override /*1*/ /*fake_override*/ val step: kotlin.Long
        public final override /*1*/ /*fake_override*/ fun <get-step>(): kotlin.Long
    public open override /*1*/ fun contains(/*0*/ value: kotlin.Long): kotlin.Boolean
    public open override /*2*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.collections.LongIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.ranges.LongRange
            public final fun <get-EMPTY>(): kotlin.ranges.LongRange
    }
}

@kotlin.Deprecated(message = "This range has unclear inclusiveness of end value. Use ClosedRange instead.", replaceWith = kotlin.ReplaceWith(expression = "ClosedRange<T>", imports = {})) public interface Range</*0*/ T : kotlin.Comparable<T>> {
    public abstract val end: T
        public abstract fun <get-end>(): T
    public abstract val start: T
        public abstract fun <get-start>(): T
    public abstract operator fun contains(/*0*/ value: T): kotlin.Boolean
    public open fun isEmpty(): kotlin.Boolean
}

@kotlin.Deprecated(level = DeprecationLevel.WARNING, message = "Use IntProgression instead.", replaceWith = kotlin.ReplaceWith(expression = "IntProgression", imports = {})) public open class ShortProgression : kotlin.Progression<kotlin.Short> {
    /*primary*/ @kotlin.Deprecated(message = "This constructor will become private soon. Use ShortProgression.fromClosedRange() instead.", replaceWith = kotlin.ReplaceWith(expression = "ShortProgression.fromClosedRange(start, endInclusive, step)", imports = {})) public constructor ShortProgression(/*0*/ start: kotlin.Short, /*1*/ endInclusive: kotlin.Short, /*2*/ step: kotlin.Int)
    @kotlin.Deprecated(message = "Use 'last' property instead.") public open override /*1*/ val end: kotlin.Short
        public open override /*1*/ fun <get-end>(): kotlin.Short
    public final val first: kotlin.Short
        public final fun <get-first>(): kotlin.Short
    @kotlin.Deprecated(message = "Use 'step' property instead.", replaceWith = kotlin.ReplaceWith(expression = "step", imports = {})) public open override /*1*/ val increment: kotlin.Int
        public open override /*1*/ fun <get-increment>(): kotlin.Int
    public final val last: kotlin.Short
        public final fun <get-last>(): kotlin.Short
    @kotlin.Deprecated(message = "Use 'first' property instead.", replaceWith = kotlin.ReplaceWith(expression = "first", imports = {})) public open override /*1*/ val start: kotlin.Short
        public open override /*1*/ fun <get-start>(): kotlin.Short
    public final val step: kotlin.Int
        public final fun <get-step>(): kotlin.Int
    public open fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun iterator(): kotlin.collections.ShortIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final fun fromClosedRange(/*0*/ rangeStart: kotlin.Short, /*1*/ rangeEnd: kotlin.Short, /*2*/ step: kotlin.Int): kotlin.ranges.ShortProgression
    }
}

internal final class ShortProgressionIterator : kotlin.collections.ShortIterator {
    /*primary*/ public constructor ShortProgressionIterator(/*0*/ first: kotlin.Short, /*1*/ last: kotlin.Short, /*2*/ step: kotlin.Int)
    private final val finalElement: kotlin.Int
        private final fun <get-finalElement>(): kotlin.Int
    private final var hasNext: kotlin.Boolean
        private final fun <get-hasNext>(): kotlin.Boolean
        private final fun <set-hasNext>(/*0*/ <set-?>: kotlin.Boolean): kotlin.Unit
    private final var next: kotlin.Int
        private final fun <get-next>(): kotlin.Int
        private final fun <set-next>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public final val step: kotlin.Int
        public final fun <get-step>(): kotlin.Int
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public final override /*1*/ /*fake_override*/ fun next(): kotlin.Short
    public open override /*1*/ fun nextShort(): kotlin.Short
}

@kotlin.Deprecated(level = DeprecationLevel.WARNING, message = "Use IntRange instead.", replaceWith = kotlin.ReplaceWith(expression = "IntRange", imports = {})) public final class ShortRange : kotlin.ranges.ShortProgression, kotlin.ranges.ClosedRange<kotlin.Short> {
    /*primary*/ public constructor ShortRange(/*0*/ start: kotlin.Short, /*1*/ endInclusive: kotlin.Short)
    @kotlin.Deprecated(message = "Use endInclusive instead.", replaceWith = kotlin.ReplaceWith(expression = "endInclusive", imports = {})) public open override /*2*/ val end: kotlin.Short
        public open override /*2*/ fun <get-end>(): kotlin.Short
    public open override /*1*/ val endInclusive: kotlin.Short
        public open override /*1*/ fun <get-endInclusive>(): kotlin.Short
    public final override /*1*/ /*fake_override*/ val first: kotlin.Short
        public final override /*1*/ /*fake_override*/ fun <get-first>(): kotlin.Short
    @kotlin.Deprecated(message = "Use 'step' property instead.", replaceWith = kotlin.ReplaceWith(expression = "step", imports = {})) public open override /*1*/ /*fake_override*/ val increment: kotlin.Int
        public open override /*1*/ /*fake_override*/ fun <get-increment>(): kotlin.Int
    public final override /*1*/ /*fake_override*/ val last: kotlin.Short
        public final override /*1*/ /*fake_override*/ fun <get-last>(): kotlin.Short
    public open override /*2*/ val start: kotlin.Short
        public open override /*2*/ fun <get-start>(): kotlin.Short
    public final override /*1*/ /*fake_override*/ val step: kotlin.Int
        public final override /*1*/ /*fake_override*/ fun <get-step>(): kotlin.Int
    public open override /*1*/ fun contains(/*0*/ value: kotlin.Short): kotlin.Boolean
    public open override /*2*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ /*fake_override*/ fun iterator(): kotlin.collections.ShortIterator

    public companion object Companion {
        /*primary*/ private constructor Companion()
        public final val EMPTY: kotlin.ranges.ShortRange
            public final fun <get-EMPTY>(): kotlin.ranges.ShortRange
    }
}
